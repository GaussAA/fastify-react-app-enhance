#!/usr/bin/env node

/**
 * Áª¥Êä§Ëá™Âä®ÂåñËÑöÊú¨
 *
 * ‰æùËµñÊ∏ÖÁêÜ„ÄÅÁºìÂ≠òÊ∏ÖÁêÜ„ÄÅÁ≥ªÁªüÁª¥Êä§
 */

import { join, dirname } from 'path';
import { execSync } from 'child_process';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

class MaintenanceAutomation {
  constructor() {
    this.projectRoot = join(__dirname, '../../..');
    this.results = {
      timestamp: new Date().toISOString(),
      tasks: [],
      summary: {
        totalTasks: 0,
        completed: 0,
        failed: 0,
        spaceFreed: 0,
        filesRemoved: 0,
      },
    };
    this.config = this.loadConfig();
  }

  /**
   * ‰∏ªÁª¥Êä§ÂáΩÊï∞
   */
  async runMaintenance() {
    console.log('üîß ÂºÄÂßãÁ≥ªÁªüÁª¥Êä§...\n');

    try {
      // Ê∏ÖÁêÜ‰æùËµñ
      await this.cleanupDependencies();

      // Ê∏ÖÁêÜÁºìÂ≠ò
      await this.cleanupCaches();

      // Ê∏ÖÁêÜ‰∏¥Êó∂Êñá‰ª∂
      await this.cleanupTempFiles();

      // Ê∏ÖÁêÜÊó•ÂøóÊñá‰ª∂
      await this.cleanupLogFiles();

      // Ê∏ÖÁêÜÊûÑÂª∫‰∫ßÁâ©
      await this.cleanupBuildArtifacts();

      // ‰ºòÂåñÊï∞ÊçÆÂ∫ì
      await this.optimizeDatabase();

      // Êõ¥Êñ∞‰æùËµñ
      await this.updateDependencies();

      // ÁîüÊàêÊä•Âëä
      this.generateReport();

      console.log('\n‚úÖ Á≥ªÁªüÁª¥Êä§ÂÆåÊàêÔºÅ');
    } catch (error) {
      console.error('‚ùå Á≥ªÁªüÁª¥Êä§Â§±Ë¥•:', error.message);
      process.exit(1);
    }
  }

  /**
   * Âä†ËΩΩÈÖçÁΩÆ
   */
  loadConfig() {
    const configPath = path.join(this.projectRoot, 'maintenance-config.json');

    // ÈªòËÆ§ÈÖçÁΩÆ
    const defaultConfig = {
      cleanup: {
        nodeModules: true,
        lockFiles: false,
        cache: true,
        temp: true,
        logs: true,
        build: true,
      },
      retention: {
        logs: 30, // ‰øùÁïô30Â§©ÁöÑÊó•Âøó
        backups: 7, // ‰øùÁïô7Â§©ÁöÑÂ§á‰ªΩ
        temp: 1, // ‰øùÁïô1Â§©ÁöÑ‰∏¥Êó∂Êñá‰ª∂
      },
      optimization: {
        database: true,
        dependencies: true,
        cache: true,
      },
      update: {
        dependencies: true,
        devDependencies: true,
        major: false, // ‰∏çÊõ¥Êñ∞‰∏ªÁâàÊú¨
      },
    };

    if (fs.existsSync(configPath)) {
      try {
        const userConfig = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
        return { ...defaultConfig, ...userConfig };
      } catch (error) {
        console.log('‚ö†Ô∏è  ÈÖçÁΩÆÊñá‰ª∂Ê†ºÂºèÈîôËØØÔºå‰ΩøÁî®ÈªòËÆ§ÈÖçÁΩÆ');
        return defaultConfig;
      }
    } else {
      // ÂàõÂª∫ÈªòËÆ§ÈÖçÁΩÆÊñá‰ª∂
      fs.writeFileSync(
        configPath,
        JSON.stringify(defaultConfig, null, 2),
        'utf-8'
      );
      console.log('üìÑ Â∑≤ÂàõÂª∫ÈªòËÆ§Áª¥Êä§ÈÖçÁΩÆÊñá‰ª∂: maintenance-config.json');
      return defaultConfig;
    }
  }

  /**
   * Ê∏ÖÁêÜ‰æùËµñ
   */
  async cleanupDependencies() {
    console.log('üì¶ Ê∏ÖÁêÜ‰æùËµñÂåÖ...');

    const { cleanup } = this.config;

    if (cleanup.nodeModules) {
      await this.runTask('Ê∏ÖÁêÜ node_modules', async () => {
        const nodeModulesDirs = [
          path.join(this.projectRoot, 'node_modules'),
          path.join(this.projectRoot, 'apps/api/node_modules'),
          path.join(this.projectRoot, 'apps/web/node_modules'),
        ];

        let totalSize = 0;
        let filesRemoved = 0;

        for (const dir of nodeModulesDirs) {
          if (fs.existsSync(dir)) {
            const size = await this.getDirectorySize(dir);
            totalSize += size;
            filesRemoved += await this.countFiles(dir);

            fs.rmSync(dir, { recursive: true, force: true });
            console.log(
              `    üóëÔ∏è  Âà†Èô§: ${path.relative(this.projectRoot, dir)} (${this.formatSize(size)})`
            );
          }
        }

        return { spaceFreed: totalSize, filesRemoved };
      });
    }

    if (cleanup.lockFiles) {
      await this.runTask('Ê∏ÖÁêÜÈîÅÊñá‰ª∂', async () => {
        const lockFiles = ['package-lock.json', 'yarn.lock', 'pnpm-lock.yaml'];

        let filesRemoved = 0;

        for (const file of lockFiles) {
          const filePath = path.join(this.projectRoot, file);
          if (fs.existsSync(filePath)) {
            fs.unlinkSync(filePath);
            filesRemoved++;
            console.log(`    üóëÔ∏è  Âà†Èô§: ${file}`);
          }
        }

        return { filesRemoved };
      });
    }
  }

  /**
   * Ê∏ÖÁêÜÁºìÂ≠ò
   */
  async cleanupCaches() {
    console.log('üóÇÔ∏è  Ê∏ÖÁêÜÁºìÂ≠òÊñá‰ª∂...');

    const { cleanup } = this.config;

    if (cleanup.cache) {
      await this.runTask('Ê∏ÖÁêÜ npm ÁºìÂ≠ò', async () => {
        try {
          execSync('npm cache clean --force', {
            encoding: 'utf-8',
            cwd: this.projectRoot,
            stdio: 'pipe',
          });
          console.log('    ‚úÖ npm ÁºìÂ≠òÂ∑≤Ê∏ÖÁêÜ');
        } catch (error) {
          console.log('    ‚ö†Ô∏è  npm ÁºìÂ≠òÊ∏ÖÁêÜÂ§±Ë¥•');
        }

        try {
          execSync('pnpm store prune', {
            encoding: 'utf-8',
            cwd: this.projectRoot,
            stdio: 'pipe',
          });
          console.log('    ‚úÖ pnpm ÁºìÂ≠òÂ∑≤Ê∏ÖÁêÜ');
        } catch (error) {
          console.log('    ‚ö†Ô∏è  pnpm ÁºìÂ≠òÊ∏ÖÁêÜÂ§±Ë¥•');
        }

        return {};
      });

      await this.runTask('Ê∏ÖÁêÜÁ≥ªÁªüÁºìÂ≠ò', async () => {
        const cacheDirs = [
          path.join(this.projectRoot, '.cache'),
          path.join(this.projectRoot, '.turbo'),
          path.join(this.projectRoot, 'apps/api/.cache'),
          path.join(this.projectRoot, 'apps/web/.cache'),
          path.join(this.projectRoot, 'apps/web/dist'),
          path.join(this.projectRoot, 'apps/api/dist'),
        ];

        let totalSize = 0;
        let filesRemoved = 0;

        for (const dir of cacheDirs) {
          if (fs.existsSync(dir)) {
            const size = await this.getDirectorySize(dir);
            totalSize += size;
            filesRemoved += await this.countFiles(dir);

            fs.rmSync(dir, { recursive: true, force: true });
            console.log(
              `    üóëÔ∏è  Âà†Èô§: ${path.relative(this.projectRoot, dir)} (${this.formatSize(size)})`
            );
          }
        }

        return { spaceFreed: totalSize, filesRemoved };
      });
    }
  }

  /**
   * Ê∏ÖÁêÜ‰∏¥Êó∂Êñá‰ª∂
   */
  async cleanupTempFiles() {
    console.log('üóëÔ∏è  Ê∏ÖÁêÜ‰∏¥Êó∂Êñá‰ª∂...');

    const { cleanup, retention } = this.config;

    if (cleanup.temp) {
      await this.runTask('Ê∏ÖÁêÜ‰∏¥Êó∂Êñá‰ª∂', async () => {
        const tempDirs = [
          path.join(this.projectRoot, 'temp'),
          path.join(this.projectRoot, 'tmp'),
          path.join(this.projectRoot, '.tmp'),
        ];

        let totalSize = 0;
        let filesRemoved = 0;

        for (const dir of tempDirs) {
          if (fs.existsSync(dir)) {
            const size = await this.getDirectorySize(dir);
            totalSize += size;
            filesRemoved += await this.countFiles(dir);

            fs.rmSync(dir, { recursive: true, force: true });
            console.log(
              `    üóëÔ∏è  Âà†Èô§: ${path.relative(this.projectRoot, dir)} (${this.formatSize(size)})`
            );
          }
        }

        // Ê∏ÖÁêÜË∂ÖËøá‰øùÁïôÊúüÁöÑ‰∏¥Êó∂Êñá‰ª∂
        const cutoffDate = new Date();
        cutoffDate.setDate(cutoffDate.getDate() - retention.temp);

        const tempFiles = this.findTempFiles();
        for (const file of tempFiles) {
          const stats = fs.statSync(file);
          if (stats.mtime < cutoffDate) {
            const size = stats.size;
            totalSize += size;
            filesRemoved++;

            fs.unlinkSync(file);
            console.log(
              `    üóëÔ∏è  Âà†Èô§ËøáÊúüÊñá‰ª∂: ${path.relative(this.projectRoot, file)}`
            );
          }
        }

        return { spaceFreed: totalSize, filesRemoved };
      });
    }
  }

  /**
   * Ê∏ÖÁêÜÊó•ÂøóÊñá‰ª∂
   */
  async cleanupLogFiles() {
    console.log('üìù Ê∏ÖÁêÜÊó•ÂøóÊñá‰ª∂...');

    const { cleanup, retention } = this.config;

    if (cleanup.logs) {
      await this.runTask('Ê∏ÖÁêÜÊó•ÂøóÊñá‰ª∂', async () => {
        const cutoffDate = new Date();
        cutoffDate.setDate(cutoffDate.getDate() - retention.logs);

        const logFiles = this.findLogFiles();
        let totalSize = 0;
        let filesRemoved = 0;

        for (const file of logFiles) {
          const stats = fs.statSync(file);
          if (stats.mtime < cutoffDate) {
            const size = stats.size;
            totalSize += size;
            filesRemoved++;

            fs.unlinkSync(file);
            console.log(
              `    üóëÔ∏è  Âà†Èô§ËøáÊúüÊó•Âøó: ${path.relative(this.projectRoot, file)}`
            );
          }
        }

        return { spaceFreed: totalSize, filesRemoved };
      });
    }
  }

  /**
   * Ê∏ÖÁêÜÊûÑÂª∫‰∫ßÁâ©
   */
  async cleanupBuildArtifacts() {
    console.log('üèóÔ∏è  Ê∏ÖÁêÜÊûÑÂª∫‰∫ßÁâ©...');

    const { cleanup } = this.config;

    if (cleanup.build) {
      await this.runTask('Ê∏ÖÁêÜÊûÑÂª∫‰∫ßÁâ©', async () => {
        const buildDirs = [
          path.join(this.projectRoot, 'dist'),
          path.join(this.projectRoot, 'build'),
          path.join(this.projectRoot, 'coverage'),
          path.join(this.projectRoot, '.nyc_output'),
          path.join(this.projectRoot, 'apps/api/dist'),
          path.join(this.projectRoot, 'apps/web/dist'),
          path.join(this.projectRoot, 'apps/api/coverage'),
          path.join(this.projectRoot, 'apps/web/coverage'),
        ];

        let totalSize = 0;
        let filesRemoved = 0;

        for (const dir of buildDirs) {
          if (fs.existsSync(dir)) {
            const size = await this.getDirectorySize(dir);
            totalSize += size;
            filesRemoved += await this.countFiles(dir);

            fs.rmSync(dir, { recursive: true, force: true });
            console.log(
              `    üóëÔ∏è  Âà†Èô§: ${path.relative(this.projectRoot, dir)} (${this.formatSize(size)})`
            );
          }
        }

        return { spaceFreed: totalSize, filesRemoved };
      });
    }
  }

  /**
   * ‰ºòÂåñÊï∞ÊçÆÂ∫ì
   */
  async optimizeDatabase() {
    console.log('üóÑÔ∏è  ‰ºòÂåñÊï∞ÊçÆÂ∫ì...');

    const { optimization } = this.config;

    if (optimization.database) {
      await this.runTask('‰ºòÂåñÊï∞ÊçÆÂ∫ì', async () => {
        try {
          // ËøêË°å Prisma ÁîüÊàê
          execSync('npx prisma generate', {
            encoding: 'utf-8',
            cwd: path.join(this.projectRoot, 'apps/api'),
            stdio: 'pipe',
          });
          console.log('    ‚úÖ Prisma ÂÆ¢Êà∑Á´ØÂ∑≤ÈáçÊñ∞ÁîüÊàê');

          // ËøêË°åÊï∞ÊçÆÂ∫ìËøÅÁßª
          execSync('npx prisma migrate deploy', {
            encoding: 'utf-8',
            cwd: path.join(this.projectRoot, 'apps/api'),
            stdio: 'pipe',
          });
          console.log('    ‚úÖ Êï∞ÊçÆÂ∫ìËøÅÁßªÂ∑≤ÂÆåÊàê');
        } catch (error) {
          console.log('    ‚ö†Ô∏è  Êï∞ÊçÆÂ∫ì‰ºòÂåñÂ§±Ë¥•:', error.message);
        }

        return {};
      });
    }
  }

  /**
   * Êõ¥Êñ∞‰æùËµñ
   */
  async updateDependencies() {
    console.log('üì¶ Êõ¥Êñ∞‰æùËµñÂåÖ...');

    const { update } = this.config;

    if (update.dependencies || update.devDependencies) {
      await this.runTask('Êõ¥Êñ∞‰æùËµñÂåÖ', async () => {
        try {
          if (update.dependencies) {
            execSync('pnpm update --prod', {
              encoding: 'utf-8',
              cwd: this.projectRoot,
              stdio: 'pipe',
            });
            console.log('    ‚úÖ Áîü‰∫ß‰æùËµñÂ∑≤Êõ¥Êñ∞');
          }

          if (update.devDependencies) {
            execSync('pnpm update --dev', {
              encoding: 'utf-8',
              cwd: this.projectRoot,
              stdio: 'pipe',
            });
            console.log('    ‚úÖ ÂºÄÂèë‰æùËµñÂ∑≤Êõ¥Êñ∞');
          }
        } catch (error) {
          console.log('    ‚ö†Ô∏è  ‰æùËµñÊõ¥Êñ∞Â§±Ë¥•:', error.message);
        }

        return {};
      });
    }
  }

  /**
   * ËøêË°åÁª¥Êä§‰ªªÂä°
   */
  async runTask(name, taskFunction) {
    console.log(`  üîß ${name}...`);

    const startTime = Date.now();
    let result = {
      name,
      status: 'unknown',
      duration: 0,
      spaceFreed: 0,
      filesRemoved: 0,
      error: '',
    };

    try {
      const taskResult = await taskFunction();
      result.status = 'completed';
      result.spaceFreed = taskResult.spaceFreed || 0;
      result.filesRemoved = taskResult.filesRemoved || 0;
      result.duration = Date.now() - startTime;

      console.log(`    ‚úÖ ${name} ÂÆåÊàê (${result.duration}ms)`);
      this.results.summary.completed++;
    } catch (error) {
      result.status = 'failed';
      result.error = error.message;
      result.duration = Date.now() - startTime;

      console.log(`    ‚ùå ${name} Â§±Ë¥•: ${error.message}`);
      this.results.summary.failed++;
    }

    this.results.tasks.push(result);
    this.results.summary.totalTasks++;
    this.results.summary.spaceFreed += result.spaceFreed;
    this.results.summary.filesRemoved += result.filesRemoved;
  }

  /**
   * Ëé∑ÂèñÁõÆÂΩïÂ§ßÂ∞è
   */
  async getDirectorySize(dirPath) {
    let totalSize = 0;

    try {
      const items = fs.readdirSync(dirPath);

      for (const item of items) {
        const itemPath = path.join(dirPath, item);
        const stats = fs.statSync(itemPath);

        if (stats.isDirectory()) {
          totalSize += await this.getDirectorySize(itemPath);
        } else {
          totalSize += stats.size;
        }
      }
    } catch (error) {
      // ÂøΩÁï•ÊùÉÈôêÈîôËØØ
    }

    return totalSize;
  }

  /**
   * ËÆ°ÁÆóÊñá‰ª∂Êï∞Èáè
   */
  async countFiles(dirPath) {
    let count = 0;

    try {
      const items = fs.readdirSync(dirPath);

      for (const item of items) {
        const itemPath = path.join(dirPath, item);
        const stats = fs.statSync(itemPath);

        if (stats.isDirectory()) {
          count += await this.countFiles(itemPath);
        } else {
          count++;
        }
      }
    } catch (error) {
      // ÂøΩÁï•ÊùÉÈôêÈîôËØØ
    }

    return count;
  }

  /**
   * Ê†ºÂºèÂåñÊñá‰ª∂Â§ßÂ∞è
   */
  formatSize(bytes) {
    if (bytes === 0) return '0 B';

    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));

    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  /**
   * Êü•Êâæ‰∏¥Êó∂Êñá‰ª∂
   */
  findTempFiles() {
    const tempFiles = [];
    const tempPatterns = [
      '**/*.tmp',
      '**/*.temp',
      '**/*.log',
      '**/temp-*',
      '**/*-temp-*',
    ];

    tempPatterns.forEach(pattern => {
      try {
        const files = execSync(
          `find . -name "${pattern}" -type f 2>/dev/null`,
          {
            encoding: 'utf-8',
            cwd: this.projectRoot,
          }
        );

        files.split('\n').forEach(file => {
          if (file.trim()) {
            tempFiles.push(path.resolve(this.projectRoot, file.trim()));
          }
        });
      } catch (error) {
        // ÂøΩÁï•Êâæ‰∏çÂà∞Êñá‰ª∂ÁöÑÈîôËØØ
      }
    });

    return tempFiles;
  }

  /**
   * Êü•ÊâæÊó•ÂøóÊñá‰ª∂
   */
  findLogFiles() {
    const logFiles = [];
    const logPatterns = ['**/*.log', '**/logs/**/*', '**/log/**/*'];

    logPatterns.forEach(pattern => {
      try {
        const files = execSync(
          `find . -name "${pattern}" -type f 2>/dev/null`,
          {
            encoding: 'utf-8',
            cwd: this.projectRoot,
          }
        );

        files.split('\n').forEach(file => {
          if (file.trim()) {
            logFiles.push(path.resolve(this.projectRoot, file.trim()));
          }
        });
      } catch (error) {
        // ÂøΩÁï•Êâæ‰∏çÂà∞Êñá‰ª∂ÁöÑÈîôËØØ
      }
    });

    return logFiles;
  }

  /**
   * ÁîüÊàêÊä•Âëä
   */
  generateReport() {
    console.log('\nüìä Áª¥Êä§Êä•Âëä');
    console.log('='.repeat(50));

    // ÊòæÁ§∫ÊëòË¶Å
    console.log(`\nüìà Áª¥Êä§ÊëòË¶Å:`);
    console.log(`  üìä ÊÄª‰ªªÂä°Êï∞: ${this.results.summary.totalTasks}`);
    console.log(`  ‚úÖ ÂÆåÊàê: ${this.results.summary.completed}`);
    console.log(`  ‚ùå Â§±Ë¥•: ${this.results.summary.failed}`);
    console.log(
      `  üíæ ÈáäÊîæÁ©∫Èó¥: ${this.formatSize(this.results.summary.spaceFreed)}`
    );
    console.log(`  üóëÔ∏è  Âà†Èô§Êñá‰ª∂: ${this.results.summary.filesRemoved}`);

    // ÊòæÁ§∫ËØ¶ÁªÜÁªìÊûú
    console.log(`\nüìã ËØ¶ÁªÜÁªìÊûú:`);
    this.results.tasks.forEach(task => {
      const icon = task.status === 'completed' ? '‚úÖ' : '‚ùå';
      const duration = `${task.duration}ms`;
      const spaceFreed =
        task.spaceFreed > 0 ? ` (${this.formatSize(task.spaceFreed)})` : '';
      const filesRemoved =
        task.filesRemoved > 0 ? ` (${task.filesRemoved} Êñá‰ª∂)` : '';

      console.log(
        `  ${icon} ${task.name} (${duration})${spaceFreed}${filesRemoved}`
      );

      if (task.status === 'failed' && task.error) {
        console.log(`     ÈîôËØØ: ${task.error}`);
      }
    });

    // ÁîüÊàêÂª∫ËÆÆ
    this.generateRecommendations();

    // ‰øùÂ≠òÊä•Âëä
    this.saveReportToFile();
  }

  /**
   * ÁîüÊàêÂª∫ËÆÆ
   */
  generateRecommendations() {
    console.log(`\nüí° Áª¥Êä§Âª∫ËÆÆ:`);

    if (this.results.summary.spaceFreed > 0) {
      console.log(
        `  1. üíæ Â∑≤ÈáäÊîæ ${this.formatSize(this.results.summary.spaceFreed)} Á©∫Èó¥`
      );
    }

    if (this.results.summary.failed > 0) {
      console.log(
        `  2. ‚ùå ${this.results.summary.failed} ‰∏™‰ªªÂä°Â§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÈîôËØØ‰ø°ÊÅØ`
      );
    }

    console.log(`\nüõ†Ô∏è  Áª¥Êä§ÂëΩ‰ª§:`);
    console.log(`  pnpm run maintenance      # ËøêË°åÁ≥ªÁªüÁª¥Êä§`);
    console.log(`  pnpm run clean            # Ê∏ÖÁêÜÈ°πÁõÆÊñá‰ª∂`);
    console.log(`  pnpm run check:all        # ËøêË°åÊâÄÊúâÊ£ÄÊü•`);
  }

  /**
   * ‰øùÂ≠òÊä•ÂëäÂà∞Êñá‰ª∂
   */
  saveReportToFile() {
    const outputDir = path.join(
      this.projectRoot,
      'docs',
      'generated',
      'reports',
      'maintenance'
    );
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // ‰øùÂ≠ò JSON Êä•Âëä
    const jsonPath = path.join(outputDir, 'maintenance.json');
    fs.writeFileSync(jsonPath, JSON.stringify(this.results, null, 2), 'utf-8');

    // ÁîüÊàê Markdown Êä•Âëä
    const markdownReport = this.generateMarkdownReport();
    const mdPath = path.join(outputDir, 'maintenance.md');
    fs.writeFileSync(mdPath, markdownReport, 'utf-8');

    console.log(`\nüìÑ Áª¥Êä§Êä•ÂëäÂ∑≤‰øùÂ≠ò:`);
    console.log(`  JSON: ${jsonPath}`);
    console.log(`  Markdown: ${mdPath}`);
  }

  /**
   * ÁîüÊàê Markdown Êä•Âëä
   */
  generateMarkdownReport() {
    const timestamp = new Date().toISOString();

    let report = `# Á≥ªÁªüÁª¥Êä§Êä•Âëä\n\n`;
    report += `**ÁîüÊàêÊó∂Èó¥**: ${timestamp}\n\n`;

    // ÊëòË¶Å
    report += `## üìä Áª¥Êä§ÊëòË¶Å\n\n`;
    report += `| ÊåáÊ†á | Êï∞ÂÄº |\n`;
    report += `|------|------|\n`;
    report += `| üìä ÊÄª‰ªªÂä°Êï∞ | ${this.results.summary.totalTasks} |\n`;
    report += `| ‚úÖ ÂÆåÊàê | ${this.results.summary.completed} |\n`;
    report += `| ‚ùå Â§±Ë¥• | ${this.results.summary.failed} |\n`;
    report += `| üíæ ÈáäÊîæÁ©∫Èó¥ | ${this.formatSize(this.results.summary.spaceFreed)} |\n`;
    report += `| üóëÔ∏è Âà†Èô§Êñá‰ª∂ | ${this.results.summary.filesRemoved} |\n\n`;

    // ËØ¶ÁªÜÁªìÊûú
    if (this.results.tasks.length > 0) {
      report += `## üìã ËØ¶ÁªÜÁªìÊûú\n\n`;
      report += `| ‰ªªÂä° | Áä∂ÊÄÅ | ËÄóÊó∂ | ÈáäÊîæÁ©∫Èó¥ | Âà†Èô§Êñá‰ª∂ |\n`;
      report += `|------|------|------|----------|----------|\n`;

      this.results.tasks.forEach(task => {
        const icon = task.status === 'completed' ? '‚úÖ' : '‚ùå';
        const status = task.status === 'completed' ? 'ÂÆåÊàê' : 'Â§±Ë¥•';
        const spaceFreed =
          task.spaceFreed > 0 ? this.formatSize(task.spaceFreed) : '-';
        const filesRemoved = task.filesRemoved > 0 ? task.filesRemoved : '-';

        report += `| ${icon} ${task.name} | ${status} | ${task.duration}ms | ${spaceFreed} | ${filesRemoved} |\n`;
      });
      report += '\n';
    }

    // Â§±Ë¥•‰ªªÂä°ËØ¶ÊÉÖ
    const failedTasks = this.results.tasks.filter(
      task => task.status === 'failed'
    );
    if (failedTasks.length > 0) {
      report += `## ‚ùå Â§±Ë¥•‰ªªÂä°ËØ¶ÊÉÖ\n\n`;
      failedTasks.forEach(task => {
        report += `### ${task.name}\n\n`;
        report += `**ÈîôËØØ‰ø°ÊÅØ**: ${task.error}\n\n`;
      });
    }

    // Áª¥Êä§Âª∫ËÆÆ
    report += `## üí° Áª¥Êä§Âª∫ËÆÆ\n\n`;
    report += `\`\`\`bash\n`;
    report += `# ËøêË°åÁ≥ªÁªüÁª¥Êä§\n`;
    report += `pnpm run maintenance\n\n`;
    report += `# Ê∏ÖÁêÜÈ°πÁõÆÊñá‰ª∂\n`;
    report += `pnpm run clean\n\n`;
    report += `# ËøêË°åÊâÄÊúâÊ£ÄÊü•\n`;
    report += `pnpm run check:all\n`;
    report += `\`\`\`\n\n`;

    report += `---\n\n`;
    report += `*Ê≠§Êä•ÂëäÁî±Á≥ªÁªüÁª¥Êä§ËÑöÊú¨Ëá™Âä®ÁîüÊàê*\n`;

    return report;
  }
}

// ÊâßË°åÁª¥Êä§
const maintenance = new MaintenanceAutomation();
maintenance.runMaintenance().catch(console.error);

export { MaintenanceAutomation };
